module: digitizers
block: post_mortem_sink
label: Post-Mortem Sink
blocktype: sync_block
includes:
  - gnuradio/digitizers/sink_common.h

parameters:
-   id: name
    label: Name
    dtype: string
-   id: unit
    label: Unit
    dtype: string
-   id: sample_rate
    label: Sample Rate (Hz)
    dtype: rf32
    gettable: true
-   id: buffer_size
    label: Buffer Size
    dtype: size
    gettable: true
    default: 100000

callbacks:
    - id: get_metadata # TODO(PORT) do we really need this getter, can't we just make name and unit gettable?
      return: signal_metadata_t
      const: true
    - id: freeze_buffer
      return: void
    - id: get_post_mortem_data
      return: post_mortem_data_t
      args:
      - id: items_to_read
        dtype: size

ports:
-   domain: stream
    id: in_data
    direction: input
    type: rf32
-   domain: stream
    id: in_errors
    direction: input
    type: rf32
    optional: true # TODO(PORT) really optional? io_signature says 2..2, checks for second input
-   domain: stream
    id: out_data
    direction: output
    type: rf32
-   domain: stream
    id: out_errors
    direction: output
    type: rf32
    optional: true

implementations:
-   id: cpu

file_format: 1

doc:
  brief: Post-mortem sink
  detail: |-
        This is a sync data block (or pass-trough data block) allowing the users to
        expose post-mortem data to the FESA control system. All incoming samples are
        copied to the outputs and at the same time stored in a circular buffer.

        The circular buffer can be frozen by using the post_mortem_sink::freeze_buffer
        method and the data can be obtained by using the post_mortem_sink::get_items
        method.

        It is important to notice that calling the post_mortem_sink::get_data method
        unfreezes the buffer meaning the clients must make sure that all the data is
        read out in a single call to the post_mortem_sink::get_data method.

        This sink should be used for streaming data only because internally
        it is assumed that items are evenly spaced between each other (important for
        calculating timestamps).

        Incoming samples are passed trough while the buffer is frozen.
